---
title: "Xeva Tutorial"
author: "Arvind Mer"
date: "`r Sys.Date()`"
output: pdf_document
vignette: >
  %\VignetteIndexEntry{Introduction to the Xeva R package}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

Load Xeva library and KRAS/P53 PDX data
```{r load, echo=TRUE}
library(Xeva)
data(lpdx)
```


To see all the model.id
```{r, echo=TRUE}
lpdx.mod = modelInfo(lpdx)
head(lpdx.mod$model.id)
```

To get the data for one model.id
```{r, echo=TRUE}
modId = lpdx.mod$model.id[82]
df = getExperiment(lpdx, model.id = modId)
head(df)
```

In the data.fram df you will see that for first 3 time points dose is 0, which indicate no treatment is given during this time. If you want the data only during the treatment periode specify treatment.only = TRUE

```{r, echo=TRUE}
df = getExperiment(lpdx, modId, treatment.only = TRUE)
head(df)
```


Models which are replicates are stored togather in expDesign slot. To get the data for all the replicates pass the 'batch.name' in the getExperiment function.

```{r, echo=TRUE}
print(batchNames(lpdx))
df = getExperiment(lpdx, batch.name = batchNames(lpdx)[1], treatment.only = TRUE)
head(df)
```

Here the data.fram contaions an extra column 'exp.type' . This indicates if this is treatment or control. 

To calculate angle between the treatment and control samples of this batch
```{r, echo=TRUE,fig.width = 12, fig.height = 12}
batchNames <- batchNames(lpdx)
expDesign  <- expDesign(lpdx, batchNames[1])
#ang <- calculateAngle(lpdx, expDesign, treatment.only = TRUE, plot=TRUE)
#print(ang)

#par(mfrow=c(5,3))
for(I in batchNames)
{
  expDesign  <- expDesign(lpdx, I)
  #ang <- calculateAngle(lpdx, expDesign, treatment.only = TRUE, plot=TRUE)
#  print(ang)
}

```

Summarize Response of PDXs
Get slop of each model and combine summarize all model slop which belongs to same patient by "mean"
```{r, echo=TRUE}
lpdx_slop <- summarizeResponse(lpdx, response.measure = "slop", 
                               group.by="patient.id", summary.stat = "mean")


```


Get angle between treatment and control model ids. For each batch it will give one angle value
```{r, echo=TRUE}
lpdx_angle <- summarizeResponse(lpdx, response.measure = "angle")

```


Get mutation expression profile 
```{r, echo=TRUE}
ldxe_mut <- getMolecularProfiles(lpdx, data.type="mutation")
print(ldxe_mut)
```

The sample names in expression set are called biobase.id in model slot.
Sample names from the expression set canb be be mapped to individual PDX model.ids as
```{r, echo=TRUE}
# get sample names
library(Biobase)
sn <- Biobase::sampleNames(ldxe_mut)
smap <- mapModelSlotIds(lpdx, id=sn, id.name = "biobase.id", map.to = "model.id")
head(smap)
```



What should we do here 
```{r, echo=TRUE}
df = getExperiment(lpdx, "PHLC119_P5.506.B1")
#print(df[df$time>85 & df$time<109, c("time", "width", "length", "volume", "comment", "dose")])
```



\pagebreak

Create mRECIST plot for PDXE Lung Cancer data
```{r, echo=TRUE, fig.width = 12, fig.height = 10}
data(pdxe)
df <- getmRECIST(pdxe)
## add tumor.type information
dfMap <- mapModelSlotIds(object=pdxe, id=df$model.id, id.name="model.id",
                        map.to="tumor.type", unique = FALSE)
if(all(df$model.id==dfMap$model.id)) {df$tumor.type = dfMap$tumor.type}
lungDf = df[df$tumor.type=="NSCLC", ]
#pdf(file="DATA-raw/mRECIST_plot_NSCLC.pdf", width=12, height=10)
plotmRECIST(lungDf, groupBy = "biobase.id", control.name = "untreated")

#pdf(file="DATA-raw/mRECIST_plot_BRCA.pdf", width=12, height=10)
brDF = df[df$tumor.type=="BRCA", ]
plotmRECIST(brDF, groupBy = "biobase.id", control.name = "untreated")
#dev.off()
```







Creat mR vs slop bar-plot
```{r, echo=TRUE, fig.width = 12, fig.height = 10}
data(pdxe)

pm = modelInfo(pdxe)
lungPID = unique(pm[pm$tumor.type=="NSCLC", "patient.id"])

pdxe_slop <- summarizeResponse(pdxe, response.measure = "slop", 
                               group.by="patient.id", summary.stat = "mean")

lung_pdxe_slope <- pdxe_slop[, lungPID]

##-------
pdxe_mR <- summarizeResponse(pdxe, response.measure = "mRECIST_recomputed", 
                               group.by="patient.id")

lung_pdxe_mR = pdxe_mR[, lungPID]

slope=c(); mR=c()
for(dn in rownames(lung_pdxe_slope))
{
  for(pi in colnames(lung_pdxe_slope))
  {
    v = c(lung_pdxe_slope[dn,pi], lung_pdxe_mR[dn,pi])
    if(!is.na(v[1]) & !is.na(v[1]))
    { slope = c(slope,v[1]); mR=c(mR,v[2]) }
  }
}

df = data.frame(mR= mR, slope= as.numeric(slope), stringsAsFactors = FALSE)
df$mR= factor(df$mR, c("CR", "PR", "SD", "PD"))

colPalette = c("#377eb8", "#4daf4a", "#fec44f", "#e41a1c")
#pdf(file="DATA-raw/boxplot_lungCancer.pdf", width=12, height=10)
boxplot(slope~mR, data=df, col=colPalette,
  main="mRECIST vs slope", xlab="mRECIST", ylab="slope")
#dev.off()
```


<!-- \pagebreak -->
<!-- This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>. -->

<!-- When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this: -->

<!-- ```{r cars} -->
<!-- summary(cars) -->
<!-- ``` -->

<!-- ```{r cars2} -->
<!-- summary(cars) -->
<!-- ``` -->
<!-- ## Including Plots -->

<!-- You can also embed plots, for example: -->

<!-- ```{r pressureX, , include=TRUE, echo=FALSE} -->
<!-- plot(pressure) -->
<!-- ``` -->

<!-- Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot. -->
